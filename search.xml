<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Miller_Rabin素数测试</title>
      <link href="/2019/04/20/8/"/>
      <url>/2019/04/20/8/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>当我们需要判断一个大数是否为素数，而$O(\sqrt n)$的时间复杂度又不可接受时，就需要用到Miller_Raibin素数测试了。Miller_Rabin素数测试是一种随机算法，但是正确率可以接受。</p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><h3 id="费马小定理测试"><a href="#费马小定理测试" class="headerlink" title="费马小定理测试"></a>费马小定理测试</h3><p>由费马小定理，我们知道若$p$是素数，那么对于$\forall a\in(0,p)$有$a^{p-1}\equiv 1(\mod p)$。它的逆否命题同样成立。</p><h3 id="二次探测测试"><a href="#二次探测测试" class="headerlink" title="二次探测测试"></a>二次探测测试</h3><p>如果$p$是素数，那么对于方程$a^2\equiv1 (\mod p)$在$a\in(0,p)$中的解只有$a=1$或$a=p-1$。它的逆否命题成立。</p><h3 id="Miller-Rabin"><a href="#Miller-Rabin" class="headerlink" title="Miller_Rabin"></a>Miller_Rabin</h3><p>假设我们现在判定$n$是否为素数。</p><p>首先排除$n&lt;2$和$n\equiv0(\mod 2)$的情况。现在$n$是一个正奇数，那么$n-1$一定是一个正偶数。</p><p>我们可以把$n-1$写成$m*2^p$，其中$m$是正奇数，$p$是正整数。</p><p>然后选定多个底$a\in (1,p)$，进行费马小定理测试和对$(a^m)^2,(a^{2m})^2,(a^{2^2m})^2,\cdots,(a^{2^{p-1}m})^2$进行二次探测测试。</p><p>如果选定不同$a$的个数为$T$，那么Miller_Rabin出错的概率是$(\frac{1}{4})^T$。当$T$较大时就可以承受了。</p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><pre><code>#include &lt;bits/stdc++.h&gt;#define LL long longusing namespace std;LL FastPow( LL x, LL y, LL Mod ) {    LL Ans = 1;    for( ; y; y &gt;&gt;= 1, x = ( __int128 ) x * x % Mod )        if( y &amp; 1 )            Ans = ( __int128 ) Ans * x % Mod;    return Ans;}bool Miller_Rabin( LL n, LL Times ) {    if( n == 2 || n == 3 ) return true;    if( n &lt; 2 || n % 2 == 0 ) return false;    LL m = n - 1, p = 0;    while( !( m &amp; 1 ) ) {        m &gt;&gt;= 1;        ++p;    }    if( n == 2 || n == 3 ) return true;    if( n &lt; 2 || n % 2 == 0 ) return false;    for( LL i = 0; i &lt; Times; ++i ) {        LL a = rand() % ( n - 2 ) + 2;        a = FastPow( a, m, n );        for( LL i = 1; i &lt;= p; ++i ) {            LL b = a;            a = ( __int128 ) a * a % n;            if( a == 1 &amp;&amp; b != 1 &amp;&amp; b != n - 1 ) return false;        }        if( a != 1 ) return false;    }    return true;}int main() {    srand( ( unsigned LL ) &quot;应该不会卡19260817&quot; );    LL n;    while( scanf( &quot;%lld&quot;, &amp;n ) == 1 )            if( Miller_Rabin( n, 8 ) ) printf( &quot;Y\n&quot; ); else printf( &quot;N\n&quot; );    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OI学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小割树</title>
      <link href="/2019/04/19/7/"/>
      <url>/2019/04/19/7/</url>
      
        <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>解决问题<a href="https://loj.ac/problem/2042" target="_blank" rel="noopener">「CQOI2016」不同的最小割</a>。</p><h2 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h2><p>最小割树用于解决一类多点之间最小割的问题。luogu上的题：<a href="https://www.luogu.org/problemnew/show/P4897" target="_blank" rel="noopener">【模板】最小割树（Gomory-Hu Tree）</a>。然后我们借助这道模板题来看看如何实现。</p><p>首先我们选择两个点$x$和$y$，求出它们的最小割。它们的最小割把点集分成了两个部分$U$和$V$。然后对于任意$x’\in U$和$y’\in V$，都有$x’$与$y’$之间的最小割不大于$x$和$y$之间的最小割（反证法易证）。这样我们可以在$U$和$V$之间连一条权值为$x$到$y$最小割的边，然后对集合$U$和$V$分别进行类似操作，我们就得到了一棵最小割树。容易发现两个点之间的最小割就是它们树上简单路径上权值最小边的权值。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>我们发现每次连一条边，都需要求一次最小割。而边总共有$n-1$条。如果使用$Dinic$或$ISAP$，那么理论时间复杂度上限为$O(n^3m)$。<del>可以无视，谁叫它的上界那么松。</del>同样的，如果使用$HLPP$，那么理论上限就是$O(n^3\sqrt m)$。<del>但是对于随机数据，ISAP的表现远好于HLPP。</del></p><h2 id="解决目标的最后一步"><a href="#解决目标的最后一步" class="headerlink" title="解决目标的最后一步"></a>解决目标的最后一步</h2><p>前面提到，两个点之间的最小割就是它们树上简单路径上权值最小边的权值，那么对于模板题，只需要再套一层倍增即可。而对于目标题我们甚至不需要把树建出来，只需要统计不同的边权即可。</p><h3 id="参考代码（【模板】最小割树（Gomory-Hu-Tree））"><a href="#参考代码（【模板】最小割树（Gomory-Hu-Tree））" class="headerlink" title="参考代码（【模板】最小割树（Gomory-Hu Tree））"></a>参考代码（【模板】最小割树（Gomory-Hu Tree））</h3><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int Maxn = 510;const int Maxm = 1510;const int INF = 2147483647;const int MaxLog = 20;int n, m, Q[ Maxn ], P[ Maxn ], q;int Start[ Maxn ], Cur[ Maxn ], Next[ Maxm &lt;&lt; 1 ], To[ Maxm &lt;&lt; 1 ], Flow[ Maxm &lt;&lt; 1 ], NowFlow[ Maxm &lt;&lt; 1 ], Used;int Start_[ Maxn ], Next_[ Maxn &lt;&lt; 1 ], To_[ Maxn &lt;&lt; 1 ], Val_[ Maxn &lt;&lt; 1 ], Used_, D[ Maxn ][ MaxLog ][ 2 ], Deep_[ Maxn ];int Deep[ Maxn ], Dis[ Maxn ], L, R, Queue[ Maxn ];inline void AddEdge( int x, int y, int z ) {    ++Used;    Next[ Used ] = Start[ x ];    To[ Used ] = y;    Flow[ Used ] = z;    Start[ x ] = Used;    return;}inline void AddEdge_( int x, int y, int z ) {    ++Used_;    Next_[ Used_ ] = Start_[ x ];    To_[ Used_ ] = y;    Val_[ Used_ ] = z;    Start_[ x ] = Used_;    return;}bool Bfs( int S, int T ) {    memset( Deep, 0, sizeof( Deep ) );    memset( Dis, 0, sizeof( Dis ) );    Deep[ S ] = 1;    L = R = 0;    Queue[ ++R ] = S;    while( L &lt; R ) {        int u = Queue[ ++L ];        for( int t = Start[ u ]; t != -1; t = Next[ t ] ) {            int v = To[ t ];            if( Deep[ v ] ) continue;            if( NowFlow[ t ] &lt;= 0 ) continue;            Deep[ v ] = Deep[ u ] + 1;            Queue[ ++R ] = v;        }    }    return Deep[ T ];}int Dfs( int u, int Rest, int T ) {    if( u == T || Rest &lt;= 0 ) return Rest;    int Ans = 0;    for( int &amp;t = Cur[ u ]; t != -1; t = Next[ t ] ) {        int v = To[ t ];        if( Deep[ v ] != Deep[ u ] + 1 ) continue;        if( NowFlow[ t ] &lt;= 0 ) continue;        int d = Dfs( v, min( Rest, NowFlow[ t ] ), T );        NowFlow[ t ] -= d; NowFlow[ t ^ 1 ] += d;        Ans += d; Rest -= d;        if( !Rest ) break;    }    return Ans;}int Dinic( int S, int T ) {    int Ans = 0;    memcpy( NowFlow, Flow, sizeof( Flow ) );    while( Bfs( S, T ) ) {        memcpy( Cur, Start, sizeof( Start ) );        int d = Dfs( S, INF, T );        while( d ) {            Ans += d;            d = Dfs( S, INF, T );        }    }    return Ans;}void Build( int Left, int Right ) {    if( Left &gt;= Right ) return;    int t = Dinic( Q[ Left ], Q[ Left + 1 ] );    AddEdge_( Q[ Left ], Q[ Left + 1 ], t );    Bfs( Q[ Left ], n + 1 );    t =  Left - 1;    for( int i = Left; i &lt;= Right; ++i )         if( Deep[ Q[ i ] ] )            P[ ++t ] = Q[ i ];    int Cut = t;    for( int i = Left; i &lt;= Right; ++i )         if( !Deep[ Q[ i ] ] )            P[ ++t ] = Q[ i ];    for( int i = Left; i &lt;= Right; ++i )         Q[ i ] = P[ i ];    Build( Left, Cut );    Build( Cut + 1, Right );    return;}void Build_( int u, int Fa, int c ) {    D[ u ][ 0 ][ 0 ] = Fa;    for( int i = 1; i &lt; MaxLog; ++i ) D[ u ][ i ][ 0 ] = D[ D[ u ][ i - 1 ][ 0 ] ][ i - 1 ][ 0 ];    D[ u ][ 0 ][ 1 ] = c;    for( int i = 1; i &lt; MaxLog; ++i ) D[ u ][ i ][ 1 ] = min( D[ u ][ i - 1 ][ 1 ], D[ D[ u ][ i - 1 ][ 0 ] ][ i - 1 ][ 1 ] );    Deep_[ u ] = Deep_[ Fa ] + 1;    for( int t = Start_[ u ]; t; t = Next_[ t ] ) {        int v = To_[ t ];        if( v == Fa ) continue;        Build_( v, u, Val_[ t ] );    }    return;}int Query( int x, int y ) {    int Ans = INF;    if( Deep_[ x ] &lt; Deep_[ y ] ) swap( x, y );    for( int i = MaxLog - 1; i &gt;= 0; --i )        if( Deep_[ D[ x ][ i ][ 0 ] ] &gt;= Deep_[ y ] ) {            Ans = min( Ans, D[ x ][ i ][ 1 ] );            x = D[ x ][ i ][ 0 ];        }    if( x == y ) return Ans;    for( int i = MaxLog - 1; i &gt;= 0; --i )         if( D[ x ][ i ][ 0 ] != D[ y ][ i ][ 0 ] ) {            Ans = min( Ans, D[ x ][ i ][ 1 ] );            Ans = min( Ans, D[ y ][ i ][ 1 ] );            x = D[ x ][ i ][ 0 ];            y = D[ y ][ i ][ 0 ];        }    Ans = min( Ans, D[ x ][ 0 ][ 1 ] );    Ans = min( Ans, D[ y ][ 0 ][ 1 ] );    return Ans;}int main() {    Used = -1;    memset( Start, 255, sizeof( Start ) );    scanf( &quot;%d%d&quot;, &amp;n, &amp;m );    for( int i = 1; i &lt;= m; ++i ) {        int x, y, z;        scanf( &quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z );        AddEdge( x, y, z );        AddEdge( y, x, z );    }    for( int i = 0; i &lt;= n; ++i ) Q[ i ] = i;    Build( 0, n );    Build_( 0, 0, INF );    scanf( &quot;%d&quot;, &amp;q );    for( int i = 1; i &lt;= q; ++i ) {        int x, y;        scanf( &quot;%d%d&quot;, &amp;x, &amp;y );        printf( &quot;%d\n&quot;, Query( x, y ) );    }    return 0;}</code></pre><h3 id="参考代码（「CQOI2016」不同的最小割）"><a href="#参考代码（「CQOI2016」不同的最小割）" class="headerlink" title="参考代码（「CQOI2016」不同的最小割）"></a>参考代码（「CQOI2016」不同的最小割）</h3><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int Maxn = 860;const int Maxm = 8510;const int INF = 2147483647;const int MaxLog = 20;int n, m, Q[ Maxn ], P[ Maxn ], q;int Start[ Maxn ], Cur[ Maxn ], Next[ Maxm &lt;&lt; 1 ], To[ Maxm &lt;&lt; 1 ], Flow[ Maxm &lt;&lt; 1 ], NowFlow[ Maxm &lt;&lt; 1 ], Used;int Deep[ Maxn ], Dis[ Maxn ], L, R, Queue[ Maxn ];map&lt; int, int &gt; Map;int Ans;inline void AddEdge( int x, int y, int z ) {    ++Used;    Next[ Used ] = Start[ x ];    To[ Used ] = y;    Flow[ Used ] = z;    Start[ x ] = Used;    return;}bool Bfs( int S, int T ) {    memset( Deep, 0, sizeof( Deep ) );    memset( Dis, 0, sizeof( Dis ) );    Deep[ S ] = 1;    L = R = 0;    Queue[ ++R ] = S;    while( L &lt; R ) {        int u = Queue[ ++L ];        for( int t = Start[ u ]; t != -1; t = Next[ t ] ) {            int v = To[ t ];            if( Deep[ v ] ) continue;            if( NowFlow[ t ] &lt;= 0 ) continue;            Deep[ v ] = Deep[ u ] + 1;            Queue[ ++R ] = v;        }    }    return Deep[ T ];}int Dfs( int u, int Rest, int T ) {    if( u == T || Rest &lt;= 0 ) return Rest;    int Ans = 0;    for( int &amp;t = Cur[ u ]; t != -1; t = Next[ t ] ) {        int v = To[ t ];        if( Deep[ v ] != Deep[ u ] + 1 ) continue;        if( NowFlow[ t ] &lt;= 0 ) continue;        int d = Dfs( v, min( Rest, NowFlow[ t ] ), T );        NowFlow[ t ] -= d; NowFlow[ t ^ 1 ] += d;        Ans += d; Rest -= d;        if( !Rest ) break;    }    return Ans;}int Dinic( int S, int T ) {    int Ans = 0;    memcpy( NowFlow, Flow, sizeof( Flow ) );    while( Bfs( S, T ) ) {        memcpy( Cur, Start, sizeof( Start ) );        int d = Dfs( S, INF, T );        while( d ) {            Ans += d;            d = Dfs( S, INF, T );        }    }    return Ans;}void Build( int Left, int Right ) {    if( Left &gt;= Right ) return;    int t = Dinic( Q[ Left ], Q[ Left + 1 ] );    if( Map.find( t ) == Map.end() ) {        ++Ans;        Map[ t ] = 1;    }    Bfs( Q[ Left ], n + 1 );    t =  Left - 1;    for( int i = Left; i &lt;= Right; ++i )         if( Deep[ Q[ i ] ] )            P[ ++t ] = Q[ i ];    int Cut = t;    for( int i = Left; i &lt;= Right; ++i )         if( !Deep[ Q[ i ] ] )            P[ ++t ] = Q[ i ];    for( int i = Left; i &lt;= Right; ++i )         Q[ i ] = P[ i ];    Build( Left, Cut );    Build( Cut + 1, Right );    return;}int main() {    Used = -1;    memset( Start, 255, sizeof( Start ) );    scanf( &quot;%d%d&quot;, &amp;n, &amp;m );    for( int i = 1; i &lt;= m; ++i ) {        int x, y, z;        scanf( &quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z );        AddEdge( x, y, z );        AddEdge( y, x, z );    }    for( int i = 1; i &lt;= n; ++i ) Q[ i ] = i;    Build( 1, n );    printf( &quot;%d\n&quot;, Ans );    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OI学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多项式除法</title>
      <link href="/2019/04/18/6/"/>
      <url>/2019/04/18/6/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们知道对于多项式$A$和多项式$B$，有唯一的$Q$和$R$使得$A=QB+R$，其中$\deg R &lt; \deg B$。</p><p>多项式除法就是给定$A$和$B$，求$Q$和$R$。</p><h2 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h2><p>参考<a href="http://blog.miskcoo.com/2015/05/polynomial-division" target="_blank" rel="noopener">miskcoo大佬的博客</a></p><p>已知<br>$$<br>A(x)=Q(x)B(x)+R(x)<br>$$<br>其中$n=\deg A$，$m=\deg B$，且$m\leqslant n$。那么两边乘$x^n$就有<br>$$<br>x^nA(\frac{1}{x})=x^{n-m}Q(\frac{1}{x})x^mB(\frac{1}{x})+x^{n-m+1}x^{m-1}R(\frac{1}{x})<br>$$<br>而如果$\deg A=n$，那么$x^nA(\frac{1}{x})$就表示翻转系数（可以举个例子感受一下），可以记做$A^R(x)$。</p><p>而我们发现$\deg R \leqslant m-1$，如果$R$不足$m-1$次，就在高位补$0$。而同样的$Q$也可以这样。</p><p>所以上式可以写作：<br>$$<br>A^R(x)=Q^R(x)B^R(x)+x^{n-m+1}R^R(x)<br>$$<br>两边对$x^{n-m+1}$取模也没有影响：<br>$$<br>A^R(x)\equiv Q^R(x)B^R(x)(\mod x^{n-m+1})<br>$$<br>然后我们对$B^R$求逆就可以求出$Q^R$，翻转后回代即可。</p><h2 id="参考程序"><a href="#参考程序" class="headerlink" title="参考程序"></a>参考程序</h2><pre><code>#include &lt;bits/stdc++.h&gt;#define LL long longusing namespace std;const LL Mod = 998244353;const LL MaxN = 400010;LL N, M, Q[ MaxN ], R[ MaxN ], F[ MaxN ], G[ MaxN ];void Read() {    scanf( &quot;%lld%lld&quot;, &amp;N, &amp;M );    ++N; ++M;    for( LL i = 0; i &lt; N; ++i ) scanf( &quot;%lld&quot;, &amp;F[ i ] );    for( LL i = 0; i &lt; M; ++i ) scanf( &quot;%lld&quot;, &amp;G[ i ] );    return;}void Print() {    for( LL i = 0; i &lt; N - M + 1; ++i ) printf( &quot;%lld &quot;, Q[ i ] ); printf( &quot;\n&quot; );    for( LL i = 0; i &lt; M - 1; ++i ) printf( &quot;%lld &quot;, R[ i ] ); printf( &quot;\n&quot; );    return;}LL FastPow( LL x, LL y ) {    LL Ans = 1;    for( ; y; y &gt;&gt;= 1, x = x * x % Mod )        if( y &amp; 1 )            Ans = Ans * x % Mod;    return Ans;}namespace Polynom {    LL n, Index[ MaxN ], Omega[ MaxN ], InvOmega[ MaxN ];    LL A[ MaxN ], B[ MaxN ], InvB[ MaxN ], Mul[ MaxN ];    LL a[ MaxN ], b[ MaxN ];    void Init( LL N ) {        for( n = 1; n &lt; N &lt;&lt; 1; n &lt;&lt;= 1 );        Omega[ 0 ] = 1; Omega[ 1 ] = FastPow( 3, ( Mod - 1 ) / n );        for( LL i = 2; i &lt; n; ++i ) Omega[ i ] = Omega[ i - 1 ] * Omega[ 1 ] % Mod;        InvOmega[ n - 1 ] = FastPow( Omega[ n - 1 ], Mod - 2 );        for( LL i = n - 2; i &gt;= 0; --i ) InvOmega[ i ] = InvOmega[ i + 1 ] * Omega[ 1 ] % Mod;        return;    }    void Reverse( LL *A, LL Len ) {        for( LL i = 0; i + i &lt; Len; ++i )            swap( A[ i ], A[ Len - i - 1 ] );        return;    }    void NTT( LL L, LL *A, LL *Omega ) {        for( LL i = 0; i &lt; L; ++i )            Index[ i ] = ( Index[ i &gt;&gt; 1 ] &gt;&gt; 1 ) | ( ( i &amp; 1 ) * ( L &gt;&gt; 1 ) );        for( LL i = 0; i &lt; L; ++i )            if( i &lt; Index[ i ] )                swap( A[ i ], A[ Index[ i ] ] );        for( LL HalfLen = 1; HalfLen &lt; L; HalfLen &lt;&lt;= 1 )            for( LL i = 0; i &lt; L; i += HalfLen &lt;&lt; 1 )                 for( LL j = 0; j &lt; HalfLen; ++j ) {                    LL T = Omega[ n / 2 / HalfLen * j ] * A[ i + j + HalfLen ] % Mod;                    LL t = A[ i + j ];                    A[ i + j ] = ( t + T ) % Mod;                    A[ i + j + HalfLen ] = ( t - T + Mod ) % Mod;                }        return;    }    void Inverse( LL Len, LL *A, LL *Ans ) {        if( Len == 1 ) {            Ans[ 0 ] = FastPow( A[ 0 ], Mod - 2 );            return;        }        Inverse( ( Len + 1 ) &gt;&gt; 1, A, Ans );        LL len = 1;        for( ; len &lt; Len &lt;&lt; 1; len &lt;&lt;= 1 );        memset( a, 0, sizeof( a ) );        memset( b, 0, sizeof( b ) );        for( LL i = 0; i &lt; Len; ++i ) a[ i ] = A[ i ];        for( LL i = 0; i &lt; Len; ++i ) b[ i ] = Ans[ i ];        NTT( len, a, Omega );        NTT( len, b, Omega );        for( LL i = 0; i &lt; len; ++i ) {            b[ i ] = b[ i ] * ( 2 - a[ i ] * b[ i ] % Mod ) % Mod;            b[ i ] = ( b[ i ] + Mod ) % Mod;        }        NTT( len, b, InvOmega );        LL Inv = FastPow( len, Mod - 2 );        for( LL i = 0; i &lt; len; ++i )            b[ i ] = b[ i ] * Inv % Mod;        for( LL i = Len; i &lt; len; ++i ) b[ i ] = 0;        memcpy( Ans, b, sizeof( b ) );        return;    }    void Multiply( LL Len, LL *A, LL *B, LL *Ans ) {        LL len = 1;        for( ; len &lt; Len &lt;&lt; 1; len &lt;&lt;= 1 );        NTT( len, A, Omega ); NTT( len, B, Omega );        for( LL i = 0; i &lt; len; ++i ) Ans[ i ] = A[ i ] * B[ i ] % Mod;        NTT( len, Ans, InvOmega );        LL Inv = FastPow( len, Mod - 2 );        for( LL i = 0; i &lt; len; ++i ) Ans[ i ] = Ans[ i ] * Inv % Mod;        return;    }    void Division( LL N, LL M, LL *F, LL *G, LL *Q, LL *R ) {        LL ModuleLen = N - M + 1;        memset( A, 0, sizeof( A ) );        memset( B, 0, sizeof( B ) );        for( LL i = 0; i &lt; N; ++i ) A[ i ] = F[ i ];        for( LL i = 0; i &lt; M; ++i ) B[ i ] = G[ i ];        Reverse( A, N );        Reverse( B, M );        for( LL i = ModuleLen; i &lt; N; ++i ) A[ i ] = 0;        for( LL i = ModuleLen; i &lt; M; ++i ) B[ i ] = 0;        Inverse( ModuleLen, B, InvB );        Multiply( ModuleLen, A, InvB, Q );        Reverse( Q, N - M + 1 );        memset( A, 0, sizeof( A ) );        memset( B, 0, sizeof( B ) );        for( LL i = 0; i &lt; N; ++i ) A[ i ] = G[ i ];        for( LL i = 0; i &lt; N - M + 1; ++i ) B[ i ] = Q[ i ];        Multiply( N, A, B, Mul );        for( LL i = 0; i &lt; M; ++i ) R[ i ] = ( F[ i ] - Mul[ i ] + Mod ) % Mod;        return;    }} //Polynomint main() {    Read();    Polynom::Init( N );    Polynom::Division( N, M, F, G, Q, R );    Print();    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OI学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多项式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多项式求逆</title>
      <link href="/2019/04/17/5/"/>
      <url>/2019/04/17/5/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>多项式求逆是多项式除法的基础。通过快速傅里叶变换和倍增，我们可以在$O(n \log n)$的复杂度内完成。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>定义$\deg A$表示多项式$A$的最高次数。</p><p>对于两个多项式$A$和$B$，有唯一的$A=QB+R$。其中$\deg R&lt;\deg B$。可以写成$A\equiv R(\mod B)$。</p><p>那么使$AA’\equiv 1(\mod x^n)$的$A’$为多项式$A$在$\mod x^n$意义下的逆元，其中$\deg A’ \leqslant \deg A$。可以记做$A^{-1}$。</p><h2 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h2><p>比较显然的是，当$n=1$时，$A\equiv c(\mod x^n)$,那么$A^{-1}=c^{-1}$。</p><p>当$n&gt;1$时，如果我们求出了$AA’\equiv 1(\mod x^{\lceil \frac{n}{2}\rceil})$，而因为$AA^{-1}\equiv1(\mod x^{\lceil \frac{n}{2}\rceil})$，那么一定有$AA^{-1}\equiv 1( \mod x^{\lceil \frac{n}{2}\rceil})$。</p><p>所以$A^{-1}-A’ \equiv 0(\mod x^{\lceil \frac{n}{2}\rceil})$。所以$(A^{-1})^2-2A^{-1}A’+(A’)^2\equiv 0 (\mod x^n)$。</p><p>乘上$A$，得到$A^{-1}-2A’+A(A’)^2\equiv 0(\mod x^n)$。所以$A^{-1}\equiv 2A’-A(A’)^2(\mod x^n)$。</p><p>时间复杂度为$O(n \log n)$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>实现的时候要注意细节。</p><p><a href="https://www.luogu.org/problemnew/show/P4238" target="_blank" rel="noopener">题目链接</a></p><pre><code>#include &lt;bits/stdc++.h&gt;#define LL long longusing namespace std;const LL Mod = 998244353;const LL MaxN = 400010;LL N, n, A[ MaxN ], B[ MaxN ];LL Index[ MaxN ], Omega[ MaxN ], InvOmega[ MaxN ];LL a[ MaxN ], b[ MaxN ];LL FastPow( LL x, LL y ) {    if( !y ) return 1LL;    LL t = FastPow( x, y &gt;&gt; 1 );    t = t * t % Mod;    if( y &amp; 1 ) t = t * x % Mod;    return t;}void Init() {    scanf( &quot;%lld&quot;, &amp;N );    for( LL i = 0; i &lt; N; ++i )        scanf( &quot;%lld&quot;, &amp;A[ i ] );    for( n = 1; n &lt; N &lt;&lt; 1; n &lt;&lt;= 1 );    Omega[ 0 ] = 1; Omega[ 1 ] = FastPow( 3, ( Mod - 1 ) / n );    for( LL i = 2; i &lt; n; ++i )        Omega[ i ] = Omega[ i - 1 ] * Omega[ 1 ] % Mod;    InvOmega[ n - 1 ] = FastPow( Omega[ n - 1 ], Mod - 2 );    for( LL i = n - 2; i &gt;= 0; --i )         InvOmega[ i ] = InvOmega[ i + 1 ] * Omega[ 1 ] % Mod;    return;}void Print() {    for( LL i = 0; i &lt; N; ++i )         printf( &quot;%lld &quot;, B[ i ] );    printf( &quot;\n&quot; );    return;}void NTT( LL L, LL *A, LL *Omega ) {    for( LL i = 0; i &lt; L; ++i )        Index[ i ] = ( Index[ i &gt;&gt; 1 ] &gt;&gt; 1) | ( ( i &amp; 1 ) * ( L &gt;&gt; 1 ) );    for( LL i = 0; i &lt; L; ++i )        if( i &lt; Index[ i ] )            swap( A[ i ], A[ Index [ i ] ] );    for( LL HalfLen = 1; HalfLen &lt; L; HalfLen &lt;&lt;= 1 )         for( LL i = 0; i &lt; L; i += HalfLen &lt;&lt; 1 )             for( LL j = 0; j &lt; HalfLen; ++j ) {                LL T = Omega[ n / 2 / HalfLen * j ] * A[ i + j + HalfLen ] % Mod;                LL t = A[ i + j ];                A[ i + j ] = ( t + T ) % Mod;                A[ i + j + HalfLen ] = ( t - T + Mod ) % Mod;            }    return;}void PolynomInverse( LL Len ) {    if( Len == 1 ) {        B[ 0 ] = FastPow( A[ 0 ], Mod - 2 );        return;    }    PolynomInverse( ( Len + 1 ) &gt;&gt; 1 );    LL len = 1;    for( ; len &lt; Len &lt;&lt; 1; len &lt;&lt;= 1 );    for( LL i = 0; i &lt; Len; ++i ) a[ i ] = A[ i ];    for( LL i = 0; i &lt; Len; ++i ) b[ i ] = B[ i ];    NTT( len, a, Omega ); NTT( len, b, Omega );    for( LL i = 0; i &lt; len; ++i ) {        b[ i ] = b[ i ] * ( 2 - a[ i ] * b[ i ] % Mod ) % Mod;        b[ i ] = ( b[ i ] + Mod ) % Mod;    }    NTT( len, b, InvOmega );    LL Inv = FastPow( len, Mod - 2 );    for( LL i = 0; i &lt; len; ++i )         b[ i ] = ( b[ i ] * Inv ) % Mod;    for( LL i = Len; i &lt; len; ++i ) b[ i ] = 0;    memcpy( B, b, sizeof( b ) );    memset( a, 0, sizeof( a ) );    memset( b, 0, sizeof( b ) );    return;}int main() {    Init();    PolynomInverse( N );    Print();    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OI学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多项式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速数论变换NTT</title>
      <link href="/2019/04/16/4/"/>
      <url>/2019/04/16/4/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果你没有看过<a href="../../13/2">快速傅里叶变换FFT</a>，那么建议先去了解一下再来看这篇文章。</p><p>首先恭喜你，<del>背出了FFT模板</del>学会了FFT。而我们发现，由于FFT所用的大量实数操作，有些时候无法满足精度需求。或者说，遇到模意义下的操作，FFT也无法满足需求。</p><p>所以就有了NTT。</p><h2 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h2><p>FFT能执行的原因就是巧妙地选择了单位复根。那么我们需要在模意义下找到单位复根的替代品。</p><p>我们首先看一看我们需要具有什么性质的数：</p><blockquote><p>1、$\omega_n^n=1$。</p><p>2、$\omega_n^0,\omega_n^1,…,\omega_n^{n-1}$互不相同。</p><p>3、$\omega_{kn}^{ki}=\omega_n^i$。</p><p>4、$\omega_n^k=-\omega_n^{k+\frac{n}{2}}$。</p><p>5、$\sum_{i=0}^{n-1}\omega_n^{ti}={\Large\{}\begin{matrix}0&amp;t\neq0\\n &amp; t=0\end{matrix}$。</p></blockquote><p><del>然而本蒟蒻太菜了，只能到处找资料。</del></p><p>下面的两项定义及原根的求法参考<a href="https://www.cnblogs.com/cytus/p/9296661.html" target="_blank" rel="noopener">https://www.cnblogs.com/cytus/p/9296661.html</a></p><p>首先我们定义阶：</p><p>若$m&gt;1$且$gcd(a,m)=1$，那么使得$a^r\equiv1(mod\,\,m)$的最小正整数$r$称为$a$对模$m$的阶，记做$\delta_m(a)$。</p><p>然后定义原根：</p><p>设$m$为正整数，$a$为整数，如果$\delta_m(a)=\phi(m)$，那么称$a$为模$m$的一个原根。</p><p>原根的求法：</p><p>设$\phi(m)=p_1^{e_1}p_2^{e_2}…p_n^{e_n}​$，若$g^{\frac{\phi(m)}{p_i}} \mod m \neq 1​$，那么$g​$是$m​$的一个原根。</p><p>常见的模数及其原根：<a href="http://blog.miskcoo.com/2014/07/fft-prime-table" target="_blank" rel="noopener">http://blog.miskcoo.com/2014/07/fft-prime-table</a></p><p>原根性质的证明可以参考<a href="https://www.cnblogs.com/zhouzhendong/p/Fast-Fourier-Transform.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhouzhendong/p/Fast-Fourier-Transform.html</a></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><pre><code>#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define LL long longusing namespace std;const LL Mod = 998244353;const LL Maxn = 400010;LL N, M, TotalLen, L;LL A[ Maxn ], B[ Maxn ];LL Index[ Maxn ], Omega[ Maxn ];char Ch[ Maxn ];void Exgcd( LL a, LL b, LL &amp;x, LL &amp;y ) {    if( b == 0 ) {        x = 1; y = 0; return;    }    Exgcd( b, a % b, y, x );    y -= a / b * x;    return;}LL Inv( LL a ) {    LL x, y;    Exgcd( a, Mod, x, y );    if( x &lt; 0 ) x += Mod;    return x;}LL FastPow( LL x, LL y ) {    if( y == 0 ) return 1;    LL t = FastPow( x, y / 2 );    t = t * t % Mod;    if( y &amp; 1 ) t = t * x % Mod;    return t;}void Read() {    scanf( &quot;%s&quot;, Ch );    N = strlen( Ch );    for( LL i = 0; i &lt; N; ++i ) A[ i ] = Ch[ N - 1 - i ] - &#39;0&#39;;    scanf( &quot;%s&quot;, Ch );    M = strlen( Ch );    for( LL i = 0; i &lt; M; ++i ) B[ i ] = Ch[ M - 1 - i ] - &#39;0&#39;;    return;}void Init() {    TotalLen = N + M;    for( L = 1; L &lt; TotalLen; L &lt;&lt;= 1 );    for( LL i = 0; i &lt; L; ++i )         Index[ i ] = ( Index[ i &gt;&gt; 1 ] &gt;&gt; 1 ) | ( ( i &amp; 1 ) * ( L &gt;&gt; 1 ) );    Omega[ 0 ] = 1; Omega[ 1 ] = FastPow( 3, ( Mod - 1 ) / L );    for( LL i = 2; i &lt; L; ++i )         Omega[ i ] = Omega[ i - 1 ] * Omega[ 1 ] % Mod;    return;}void NTT( LL *A ) {    for( LL i = 0; i &lt; L; ++i )         if( Index[ i ] &gt; i )            swap( A[ i ], A[ Index[ i ] ] );    for( LL HalfLen = 1; HalfLen &lt; L; HalfLen &lt;&lt;= 1 )         for( LL i = 0; i &lt; L; i += HalfLen &lt;&lt; 1 )            for( LL j = 0; j &lt; HalfLen; ++j ) {                LL T = Omega[ L / 2 / HalfLen * j ] * A[ i + j + HalfLen ] % Mod;                    LL t = A[ i + j ];                A[ i + j ] = ( t + T ) % Mod;                A[ i + j + HalfLen ] = ( t - T + Mod ) % Mod;            }    return;}void Transform() {    for( LL i = 0; i &lt; L; ++i ) A[ i ] = ( A[ i ] * B[ i ] ) % Mod;    Omega[ 1 ] = Inv( Omega[ 1 ] );    for( LL i = 2; i &lt; L; ++i )        Omega[ i ] = Omega[ i - 1 ] * Omega[ 1 ] % Mod;    return;}void Print() {    LL INV = Inv( L );    for( LL i = 0; i &lt; L; ++i )         A[ i ] = A[ i ] * INV % Mod;    for( LL i = 0; i &lt; L; ++i ) {        A[ i + 1 ] += A[ i ] / 10;        A[ i ] %= 10;    }    while( L &amp;&amp; !A[ L ] ) --L;    for( LL i = L; i &gt;= 0; --i ) printf( &quot;%lld&quot;, A[ i ] );    printf( &quot;\n&quot; );    return;}int main() {    Read();    Init();    NTT( A ); NTT( B );    Transform();    NTT( A );    Print();    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OI学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多项式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多项式学习</title>
      <link href="/2019/04/16/3/"/>
      <url>/2019/04/16/3/</url>
      
        <content type="html"><![CDATA[<h1 id="快速傅里叶变换FFT"><a href="#快速傅里叶变换FFT" class="headerlink" title="快速傅里叶变换FFT"></a><a href="../../13/2/">快速傅里叶变换FFT</a></h1><h1 id="快速数论变换NTT"><a href="#快速数论变换NTT" class="headerlink" title="快速数论变换NTT"></a><a href="../4/">快速数论变换NTT</a></h1><h1 id="多项式求逆"><a href="#多项式求逆" class="headerlink" title="多项式求逆"></a><a href="../../17/5/">多项式求逆</a></h1><h1 id="多项式除法"><a href="#多项式除法" class="headerlink" title="多项式除法"></a><a href="../../18/6/">多项式除法</a></h1>]]></content>
      
      
      <categories>
          
          <category> OI学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多项式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速傅里叶变换FFT</title>
      <link href="/2019/04/13/2/"/>
      <url>/2019/04/13/2/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>听说FFT是个很有用的东西，于是本菜鸡就<del>去背了模板</del>尝试着看了一下。这里写下菜鸡版教程。</p><h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><p>FFT主要用于求卷积。然而卷积是什么？</p><p>如果$f$是一个$n$次多项式，$g$是$m$次多项式，那么它们的卷积<br>$$<br>h(x)=f(x)g(x)=\sum_{i=0}^n\sum_{j=0}^mf_ig_jx^{i+j}=\sum_{i=0}^{n+m}\sum_{j=0}^if_{i-j}g_jx^i<br>$$<br>我们冷静分析一波，发现这就是个多项式乘法……</p><p>一般情况下，求卷积的时间复杂度是$O(n^2)$的。我们尝试加速这一过程。</p><h2 id="点值表达与离散傅里叶变换"><a href="#点值表达与离散傅里叶变换" class="headerlink" title="点值表达与离散傅里叶变换"></a>点值表达与离散傅里叶变换</h2><p>一般的，一个多项式可以表示为<br>$$<br>A(x)=a_0+a_1x+a_2x^2+…+a_nx^n<br>$$<br>这叫系数表示。</p><p>而一个$n$次多项式可以由$n+1$个互不相同的$(x,A(x))$唯一确定，其中<br>$$<br>A(x)=\{(x_0,A(x_0)),(x_1,A(x_1)),…,(x_n,A(x_n))\}<br>$$<br>叫做点值表示。</p><p>然后我们发现，点值表达有一个非常厉害的地方（$A$是$n$次多项式，$B$是$m$次多项式）：<br>$$<br>A(x)=\{(x_0,A(x_0)),(x_1,A(x_1)),…,(x_{n+m},A(x_{n+m}))\}\\<br>B(x)=\{(x_0,B(x_0)),(x_1,B(x_1)),…,(x_{n+m},B(x_{n+m}))\}\\<br>A(x)B(x)=\{(x_0,A(x_0)B(x_0)),(x_1,A(x_1)B(x_1)),…,(x_{n+m},A(x_{n+m})B(x_{n+m}))\}\\<br>$$<br>也就是说，我们可以在$O(n)$的时间内求出两个点值表达式相乘的结果！这可比先前的$O(n^2)$快了不少。</p><p>于是我们就想利用点值表达的这一特性来加速卷积过程。思路也很明显了：先将系数表示通过离散傅里叶变换（DFT）变成点值表示，求出乘积后，通过逆离散傅里叶变换（IDFT）转回系数表示。但是怎么进行DFT和IDFT呢？现在看来都是$O(n^2)$的……（IDFT通过拉格朗日插值实现，高斯消元是$O(n^3)$的）</p><h2 id="单位复根"><a href="#单位复根" class="headerlink" title="单位复根"></a>单位复根</h2><p>DFT的过程能降到$O(n\log n)$全靠单位复根。</p><p>$n$次单位复根是$n$个互不相同的$\omega^n=1$的复数。它们在复平面中的位置恰好将单位圆$n$等分。它们分别是$\omega_n^t=\cos \frac{2\pi t}{n}+i\sin\frac{2\pi t}{n}$，$t=0,1,…,n-1$。</p><p>$n=8$时差不多长这样：</p><p><img src="/2019/04/13/2/20190211102158.png" alt="图1"></p><p>结合图像，我们能得到一些显而易见的性质：<br>$$<br>\omega_{kn}^{ki}=\omega_n^i\\<br>\omega_n^i=-\omega_n^{i+\frac{n}{2}}<br>$$<br>然后我们就可以尝试DFT了。</p><h2 id="DFT"><a href="#DFT" class="headerlink" title="DFT"></a>DFT</h2><p>接下来，我们令$A$是一个$n$次多项式，$\deg A=n+1$。不妨将$\deg A$扩充到$2$的幂次。</p><p>要将$A$转成点值表示，我们需要取$\deg A$个值。</p><p>现在，我们要求$\overrightarrow{y}=(A(\omega_n^0),A(\omega_n^1),…,A(\omega_n^{n-1}))^T$。</p><p>令$A(x)=A^{[0]}(x^2)+xA^{[1]}(x^2)$（奇偶次项分开），我们可以得到：<br>$$<br>A(\omega_n^i)=A^{[0]}(\omega_n^{2i})+\omega_n^iA^{[1]}(\omega_n^{2i})=A^{[0]}(\omega_{\frac{n}{2}}^i)+\omega_n^iA^{[1]}(\omega_{\frac{n}{2}}^i)\\<br>A(\omega_n^{i+\frac{n}{2}})=A(-\omega_n^i)=A^{[0]}(\omega_{\frac{n}{2}}^i)-\omega_n^iA^{[1]}(\omega_{\frac{n}{2}}^i)<br>$$<br>所以求出<br>$$<br>\overrightarrow{y^{[0]}}=(A^{[0]}(\omega_{\frac{n}{2}}^0),A^{[0]}(\omega_{\frac{n}{2}}^1),…,A^{[0]}(\omega_{\frac{n}{2}}^{\frac{n}{2} - 1}))\\<br>\overrightarrow{y^{[1]}}=(A^{[1]}(\omega_{\frac{n}{2}}^0),A^{[1]}(\omega_{\frac{n}{2}}^1),…,A^{[1]}(\omega_{\frac{n}{2}}^{\frac{n}{2} - 1}))\\<br>\omega_n^i<br>$$<br>后就可以在$O(n)$时间内求出$\overrightarrow{y}$。这样的时间复杂度是$O(n\log n)$的。</p><h2 id="IDFT"><a href="#IDFT" class="headerlink" title="IDFT"></a>IDFT</h2><p>有了$\overrightarrow{y}$，求$A$的过程叫IDFT。我们现在令$A$的系数组成向量$\overrightarrow a$。</p><p>该过程即解方程<br>$$<br>\begin{aligned}<br>\begin{pmatrix}<br>1 &amp; \omega_n^0 &amp;… &amp; (\omega_n^0)^{n-1} \\<br>1 &amp; \omega_n^1 &amp;… &amp; (\omega_n^1)^{n-1} \\<br> &amp; &amp; … &amp; \\<br>1 &amp; \omega_n^{n-1} &amp; … &amp; (\omega_n^{n-1})^{n-1}<br>\end{pmatrix} \times \overrightarrow{a}=\overrightarrow{y}<br>\end{aligned}<br>$$<br>左边的系数矩阵是$n$阶的范德蒙德矩阵$V_n$。现在我们尝试求出$\overrightarrow{a}=V_n^{-1}\overrightarrow {y}$。</p><p>我们构造<br>$$<br>D_n=\begin{pmatrix}<br>1 &amp; (\omega_n^{0})^1 &amp; … &amp; (\omega_n^{0})^{n-1}\\<br>1 &amp; (\omega_n^{-1})^1 &amp; … &amp; (\omega_n^{-1})^{n-1}\\<br>&amp; &amp; … &amp; \\<br>1 &amp; (\omega_n^{-n+1})^1 &amp; … &amp; (\omega_n^{-n+1})^{n-1}<br>\end{pmatrix}<br>$$<br>那么<br>$$<br>(D_nV_n)_{i,j}=\sum_{k=0}^{n-1}D_{i,k}V_{k,j}=\sum_{k=0}^{n-1}(\omega_n^{-i})^k(\omega_n^k)^j=\sum_{k=0}^{n-1}\omega_n^{k(j-i)}<br>$$<br>而由于$j-i\in\{-n+1,n-1\}$，所以当$i=j$时，$(D_nV_n)_{i,j}=n$，否则$(D_nV_n)_{i,j}=\frac{1-(\omega_n^{j-i})^n}{1-\omega_n^{j-i}}=0$。</p><p>也就是说<br>$$<br>D_nV_n=nI_n<br>$$<br>所以<br>$$<br>V_n\overrightarrow{a}=\overrightarrow{y}\\<br>\Rightarrow\frac{1}{n}D_nV_n\overrightarrow{a}=\frac{1}{n}D_n\overrightarrow{y}\\<br>\Rightarrow\overrightarrow{a}=\frac{1}{n}D_n\overrightarrow{y}<br>$$<br>而我们发现DFT的过程实际上就是求<br>$$<br>\overrightarrow{y}=V_n\overrightarrow{a}<br>$$<br>所以只需要把DFT时$V_n$中的$\omega_n^i$换成$\omega_n^{-i}$即可(取虚部为相反数)。最后别忘了乘上$\frac{1}{n}$。</p><p>到此为止，已经可以写出递归版的FFT了。不过递归版的FFT常数比较大。我们来看进一步的优化：</p><h2 id="蝴蝶操作"><a href="#蝴蝶操作" class="headerlink" title="蝴蝶操作"></a>蝴蝶操作</h2><p>DFT时，我们要将系数奇偶分开。考虑递归过程中系数的变化：<br>$$<br>\begin{matrix}<br>0&amp;1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7\\<br>0&amp;2&amp;4&amp;6&amp;1&amp;3&amp;5&amp;7\\<br>0&amp;4&amp;2&amp;6&amp;1&amp;5&amp;3&amp;7<br>\end{matrix}<br>$$</p><p>$$<br>\begin{matrix}<br>000&amp;001&amp;010&amp;011&amp;100&amp;101&amp;110&amp;111\\<br>0&amp;1&amp;2 &amp;3&amp;4&amp;5&amp;6&amp;7\\<br>\\<br>0&amp;4&amp;2&amp;6&amp;1&amp;5&amp;3&amp;7\\<br>000&amp;100&amp;010&amp;110&amp;001&amp;101&amp;011&amp;111<br>\end{matrix}<br>$$</p><p>发现什么了吧。</p><p>我们可以先将系数放到对应的位置，然后从下往上一步步合并就可以了。</p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><a href="https://www.luogu.org/problemnew/show/P3803" target="_blank" rel="noopener">题目链接</a></p><pre><code>#include &lt;bits/stdc++.h&gt;#define LL long long#define LD long doubleusing namespace std;const int Maxn = 4000010;const LD Pi = 3.14159265358979323846264;struct myComplex {    LD real, imag;    myComplex operator + ( const myComplex Other ) const {        return ( myComplex ) { real + Other.real, imag + Other.imag };    }    myComplex operator - ( const myComplex Other ) const {        return ( myComplex ) { real - Other.real, imag - Other.imag };    }    myComplex operator * ( const myComplex Other ) const {        return ( myComplex ) { real * Other.real - imag * Other.imag, real * Other.imag + imag * Other.real };    }};int n, m, TotalLen, N;int Index[ Maxn ];myComplex omega[ Maxn ], A[ Maxn ], B[ Maxn ];void FFT( myComplex *A ) {    for( int i = 0; i &lt; N; ++i )         if( i &lt; Index[ i ] )             swap( A[ i ], A[ Index[ i ] ] );    for( int HalfLen = 1; HalfLen &lt; N; HalfLen &lt;&lt;= 1 )         for( int i = 0; i &lt; N; i += HalfLen &lt;&lt; 1 )            for( int j = 0; j &lt; HalfLen; ++j ) {                myComplex t = omega[ ( N / HalfLen / 2 ) * j ] * A[ i + j + HalfLen ];                myComplex T = A[ i + j ];                A[ i + j ] = T + t;                A[ i + j + HalfLen ] = T - t;            }    return;}int main() {    scanf( &quot;%d%d&quot;, &amp;n, &amp;m );    ++n; ++m; TotalLen = n + m - 1;    for( int i = 0; i &lt; n; ++i ) scanf( &quot;%Lf&quot;, &amp;A[ i ].real );    for( int i = 0; i &lt; m; ++i ) scanf( &quot;%Lf&quot;, &amp;B[ i ].real );    for( N = 1; N &lt;= TotalLen; N &lt;&lt;= 1 );    for( int i = 0; i &lt; N; ++i )         Index[ i ] = ( Index[ i &gt;&gt; 1 ] &gt;&gt; 1 ) | ( ( i &amp; 1 ) * N / 2 );    for( int i = 0; i &lt; N; ++i )         omega[ i ] = ( myComplex ) { cos( 2.0 * Pi * i / N ), sin( 2.0 * Pi * i / N ) };    FFT( A ); FFT( B );    for( int i = 0; i &lt; N; ++i ) A[ i ] = A[ i ] * B[ i ];    for( int i = 0; i &lt; N; ++i ) omega[ i ].imag = -omega[ i ].imag;    FFT( A );    for( int i = 0; i &lt; TotalLen; ++i ) printf( &quot;%d &quot;, ( int ) ( A[ i ].real / N + 0.5 ) );    printf( &quot;\n&quot; );    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OI学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多项式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何搭建一个这样的网站？</title>
      <link href="/2019/04/13/1/"/>
      <url>/2019/04/13/1/</url>
      
        <content type="html"><![CDATA[<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>本文略过git或openshift或……部分，相信大家都会。</p><p>hexo 需要nodejs与npm。所以我们首先安装：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> nodejs<span class="token function">sudo</span> apt <span class="token function">install</span> nodejs-legacy<span class="token function">sudo</span> apt <span class="token function">install</span> <span class="token function">npm</span><span class="token function">sudo</span> <span class="token function">npm</span> config <span class="token keyword">set</span> registry https://registry.npm.taobao.org<span class="token function">sudo</span> <span class="token function">npm</span> <span class="token function">install</span> n -g<span class="token function">sudo</span> n stable<span class="token function">sudo</span> <span class="token function">npm</span> <span class="token function">install</span> -g hexo-cli</code></pre><p>然后选择一个文件夹，运行</p><pre class=" language-shell"><code class="language-shell">hexo init</code></pre><p>你的网站就部署在这个文件夹下了！</p><p>然后安装一些可能需要的包：</p><pre class=" language-shell"><code class="language-shell">npm install hexo-generator-index --savenpm install hexo-generator-archive --savenpm install hexo-generator-category --savenpm install hexo-generator-tag --savenpm install hexo-server --savenpm install hexo-deployer-git --savenpm install hexo-deployer-heroku --savenpm install hexo-deployer-rsync --savenpm install hexo-deployer-openshift --savenpm install hexo-renderer-marked --savenpm install hexo-renderer-stylus --savenpm install hexo-generator-feed --savenpm install hexo-generator-sitemap --savenpm install hexo-generator-archive --savenpm install https://github.com/CodeFalling/hexo-asset-image --save</code></pre><p>其中hexo-deployer中只需选一个你需要的。</p><p>然后在这个文件夹下试一试</p><pre class=" language-shell"><code class="language-shell">hexo ghexo s</code></pre><p>然后打开<code>127.0.0.1:4000</code>，看看是否成功呢？</p><h2 id="选择主题"><a href="#选择主题" class="headerlink" title="选择主题"></a>选择主题</h2><p>本博客选用<code>matery</code>主题。到<code>hexo</code>官网就可以找到&gt;_&lt;。</p><p>在<code>_config.yml</code>中找到<code>theme</code>，改成</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># Extensions</span><span class="token comment" spellcheck="true">## Plugins: https://hexo.io/plugins/</span><span class="token comment" spellcheck="true">## Themes: https://hexo.io/themes/</span><span class="token key atrule">theme</span><span class="token punctuation">:</span> matery</code></pre><p>即可。</p><p>有关主题的更多内容请参考<code>theme/matery/README_CN.md</code>，这里不再赘述。</p><h2 id="数学公式支持"><a href="#数学公式支持" class="headerlink" title="数学公式支持"></a>数学公式支持</h2><p>其实前面的已经差不多了！</p><p>但是我们发现不能像<code>typora</code>中那样使用数学公式。</p><p>然后我用了$\infty$的时间去尝试着使用KaTeX渲染和使用Markdown支持渲染。然后嘛，最后虽然算是成功渲染了，但是好像不是那么正确……</p><p>之后就当我打算放弃使用图片时，突然发现<code>themes/matery/_config.yml</code>中有这么一段话：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># Whether to activate the mathjax, this is a global configuration, but the post still does not open the mathjax rendering.</span><span class="token comment" spellcheck="true"># Considering that the mathjax loading is time consuming,</span><span class="token comment" spellcheck="true"># you also need to add `mathjax: true` to the Front-matter of the post that needs to be rendered.</span><span class="token comment" spellcheck="true"># 是否激活mathjax数学公式，这是全局配置，但文章仍然不会都开启mathjax渲染，</span><span class="token comment" spellcheck="true"># 考虑到mathjax加载比较耗时，你还需要在需要渲染的文章的Front-matter中再加上`mathjax: true`才行.</span><span class="token key atrule">mathjax</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">cdn</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//cdn.bootcss.com/mathjax/2.7.5/MathJax.js<span class="token punctuation">?</span>config=TeX<span class="token punctuation">-</span>AMS<span class="token punctuation">-</span>MML_HTMLorMML</code></pre><p>那不是已经说得很清楚了嘛……先前我在干什么……</p><p>然后发现一点小小的问题，我们需要解决LaTeX与Html的冲突。</p><p>找到<code>node_modules\marked\lib\marked.js</code>，将其中</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">escape</span><span class="token punctuation">:</span> /^\\(<span class="token punctuation">[</span>\\`*<span class="token punctuation">{</span><span class="token punctuation">}</span>\<span class="token punctuation">[</span>\<span class="token punctuation">]</span>()<span class="token comment" spellcheck="true"># +\-.!_>])/,</span><span class="token key atrule">em</span><span class="token punctuation">:</span> /^\b_((<span class="token punctuation">?</span><span class="token punctuation">:</span><span class="token punctuation">[</span>^_<span class="token punctuation">]</span><span class="token punctuation">|</span>__)+<span class="token punctuation">?</span>)_\b<span class="token punctuation">|</span>^\*((<span class="token punctuation">?</span><span class="token punctuation">:</span>\*\*<span class="token punctuation">|</span><span class="token punctuation">[</span>\s\S<span class="token punctuation">]</span>)+<span class="token punctuation">?</span>)\*(<span class="token punctuation">?</span><span class="token tag">!\*)/,</span></code></pre><p>改为</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">escape</span><span class="token punctuation">:</span> /^\\(<span class="token punctuation">[</span>`*\<span class="token punctuation">[</span>\<span class="token punctuation">]</span>()<span class="token comment" spellcheck="true"># +\-.!_>])/,</span><span class="token key atrule">em</span><span class="token punctuation">:</span> /^\*((<span class="token punctuation">?</span><span class="token punctuation">:</span>\*\*<span class="token punctuation">|</span><span class="token punctuation">[</span>\s\S<span class="token punctuation">]</span>)+<span class="token punctuation">?</span>)\*(<span class="token punctuation">?</span><span class="token tag">!\*)/,</span></code></pre><p>即可。</p><h2 id="使用技巧和hexo相关操作"><a href="#使用技巧和hexo相关操作" class="headerlink" title="使用技巧和hexo相关操作"></a>使用技巧和hexo相关操作</h2><p>hexo常用的指令有：</p><pre class=" language-shell"><code class="language-shell">hexo clean     #清除db.json与public里面的内容hexo new file  #在source/_post下面新建一个file.md文件hexo g         #由md文件生成html静态文件hexo s         #在本地启动http服务以提供本地预览功能hexo d         #发布到GitHub</code></pre><p>建议将<code>_config.yml</code>中的<code>post_asset_folder: false</code>改为<code>true</code>。这样新建文章的时候就会同时新建一个同名文件夹，就可以把需要的东西都放进文件夹里，方便管理。</p><hr><p>以下是相关测试：</p><h2 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h2><p><strong>粗体</strong> <del>划线</del> _斜体_</p><h3 id="多级标题"><a href="#多级标题" class="headerlink" title="多级标题"></a>多级标题</h3><h4 id="多级标题-1"><a href="#多级标题-1" class="headerlink" title="多级标题"></a>多级标题</h4><blockquote><p>引用</p></blockquote><p><img src="/2019/04/13/1/1.jpg" alt="1"></p><p><img src="/2019/04/13/1/1.gif" alt="2"></p><pre><code>//代码块#include &lt;bits/stdc++.h&gt;using namespace std;int main() {    int a, b;    cin &gt;&gt; a &gt;&gt; b;    cout &lt;&lt; a + b &lt;&lt; endl;    return 0;}</code></pre><p><a href="https://www.baidu.com" target="_blank" rel="noopener">百度</a></p><p><a href="1.zip">下载测试</a></p><p>公式测试<br>$$<br>{ \sum_{i=1}^{n} i } = \frac{n\times(n+1)}{2} = \frac{ n ^ {2} + n}{2}<br>$$</p><p>行内公式测试$\sum\limits_{i=1}^{n}i = \frac{n\times(n+1)}{2}$</p>]]></content>
      
      
      <categories>
          
          <category> 经验&amp;教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
